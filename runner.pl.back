#!/usr/bin/perl


## @file runner.pl
# @brief EPP load testing script


## @class EPP::LoadRunner
#  @brief EPP load testing script
package EPP::LoadRunner;
# *********************************************************************


=pod

=head1 NAME

runner.pl

=head1 DESCRIPTION

Stress testing EPP

=head1 SYNOPSIS

runner.pl [--limit <n>]  [--time <sec>] [--threads <n> ] [--debug]

  Options:
    --help:        Print a summary of the command-line usage and exit.
    --limit:       Exit when <n> requests have sent.
    --time:        Exit wnen <sec> passed.
    --threads:     Use <n> threads for EPP requests, default = 1.
    --config:      Path to the configuration file, default conf/load.conf.
    --debug:       Each request/response body are going to logging.

=head1 EXAMPLES

./runner.pl     \
  --limit   1000  \
  --time    120    \
  --threads 10    \
  --config  conf/load.conf    \
  --debug
=cut


use strict;
use warnings;
use utf8;

use FindBin;

BEGIN { 
	unshift @INC, "$FindBin::Bin/lib";
	$ENV{HTTPS_DEBUG} = 0;  #Add debug output
}

use Pod::Usage;
use Encode qw(encode decode is_utf8);
use Encode;
use Data::Dumper;
use POSIX;
use Getopt::Long;
use Log::Log4perl;
use Time::HiRes;
use threads;
use threads::shared;
#use LWP::Debug qw(+);

use Util qw(debug trim tstamp println);
use LoadEpp;
use Stat;

# $|=1;


GetOptions(
	'limit=i'    => \( my $limit_number:shared = undef),    # limit on the number of requests during testing
	'time=i'     => \( my $limit_time:shared   = undef),    # test time limit in sec.
	'threads=i'  => \( my $limit_thread        = undef),    # number of threads
	'config=s'   => \( my $config_path:shared  = undef),    # path to config
	'debug'      => \( my $debug:shared        = undef),    # log the content of all EPP requests/responses
	"help|h"     => \( my $help                = undef),    # help
);



if ($help) {
	pod2usage( -exitstatus => 0, -verbose => 99, -sections => [ qw|NAME DESCRIPTION SYNOPSIS| ] );
}

unless ( defined $limit_number || defined $limit_time ) {
	println('Error: a limit or time parameter is required');
	exit;
}


# statistic
my $stat = shared_clone(Stat->new());

my $start_time:shared = time;
my $cur_time:shared   = $start_time;
my $c:shared = 0;


# Types of requests are laid out on a scale of 100 elements in the proportions specified in the config
# next we will use rand to determine which request to send

my $config = Util::read_yaml($config_path || 'conf/load.conf')
	or die('ERROR: Can not read config file: ' . $!);

#my %weight = (
#	check  => 70,
#	create => 30,
#);

my @prob_scale = ();

println('The request type ratio:');

my $req_ratio = $config->{req_ratio} || { check => 100 };
while ( my ($type, $chance) = each %$req_ratio  ) {
	println( sprintf('  %-7s  %s', $type.':', $chance.'%') );
	for (1 .. $chance) {
		push @prob_scale, $type;
	}
}

println;

if ( 100 != scalar @prob_scale) {
	die('ERROR: The sum of request types ratio is '. scalar @prob_scale .'%, but should be 100%, please check the req_ratio config section.');
	return;
}



$limit_thread ||= 1;

my @threads;

for my $t (1 .. $limit_thread) {
	push @threads, threads->create(\&main, $t, $stat, \@prob_scale, $debug);
}

for my $t (@threads) {
	$t->join;
}

if ( defined $limit_number && $c >= int $limit_number ) {
	println(qq{\nThe request number limit $limit_number have reached!})
}

if ( defined $limit_time && int $limit_time <= time - $start_time ) {
	println(qq{\nThe run time limit $limit_time sec have reached!});
}


println( $stat->get_summary );

sub main {

	my $thread_num = shift;
	my $stat  = shift;
	my $prob_scale  = shift;
	my $debug = shift;

	Log::Log4perl->init( {
		'log4perl.rootLogger'                   => 'INFO, LOGFILE',
		'log4perl.appender.LOGFILE'             => 'Log::Log4perl::Appender::File',
		'log4perl.appender.LOGFILE.filename'    =>  Util::abs_path('log/loader.log'),
		'log4perl.appender.LOGFILE.mode'        => 'append',
		'log4perl.appender.LOGFILE.layout'      => 'PatternLayout',
		'log4perl.appender.LOGFILE.layout.ConversionPattern' => '%d{yyyy-MM-dd HH:mm:ss} pid:%P %p %m%n',
		# 'log4perl.appender.LOGFILE.layout.ConversionPattern' => '%d{yyyy-MM-dd hh:mm:ss SSSSS} %P %p %m%n',
		# explain format: yyyy-mm-dd hh:mm:ss millisecond pid level message new_line
	});

	my $logger = Log::Log4perl->get_logger();

	my $config = Util::read_yaml($config_path || 'conf/load.conf')
		or die('ERROR: Can not read config file: ' . $!);

	my $epp = LoadEpp->new(
		logger      => $logger,
		config      => $config,
		debug       => $debug,
	);

	my $sid = $epp->connect;

	die 'ERROR: Can not connect to the EPP interface, see logs for details, rid: '.$epp->last_rid
		unless $sid;

	println('Thread '.$thread_num.': connect and loggin are success; host: '.$config->{address});

	while(1){
		# print $c;

		# reached the request or time limit
		if ( 
			( defined $limit_number && $c >= int $limit_number )
			||
			( defined $limit_time && int $limit_time <= time - $start_time )
		) {
			$epp->send_logout($sid);
			last;
		}

		++$c;

		# determine the type of request according to the specified proportion
		my $req_type = $prob_scale->[ Util::rand_range(99) ];

		# multiple domains can be passed in the check request, the number is specified in the config
		my @domains;
		if ( $req_type eq 'check' ) {
			my $domains_num = $config->{check_domains} ? Util::rand_range(@{ $config->{check_domains} }) : 1;
			for ( 1 .. $domains_num ) {
				push @domains, 'ph0enix'.int(10000000*rand).'.ru';
			}
		}
		else {
			# domain was taken from test database
			push @domains, 'domain-1-1333528984551.ru';
		}


		my $is_success = $req_type eq 'create' 
			? $epp->send_create($sid, @domains)
			: $epp->send_check($sid, @domains);

		$stat->increment($req_type => $is_success, $epp->last_elapsed, $epp->last_rid);

		# each second show the info: how much request passed,  how much left, RPS
		if (time != $cur_time and $thread_num == 1) {
			print $stat->get_stat_line( 
				$limit_number 
					? ( 'limit_number' => $limit_number )
					: ( 'limit_time'   => $limit_time )
			);
			select()->flush();
			$cur_time = time;
		}

	}

	return 1;
}









1;

__END__


